### 4. Realization of Pod Model

In the world of Kubernetes, Pod is the smallest scheduling deployment unit. In brief, a Pod is a container group composed of the relevant container. As a whole, these "intimate" containers will share something to make their interaction more efficient. For example, for the network, containers within the same Pod will share the same IP address and port, so that they can access each other through localhost. For storage, the volume defined in Pod will mount to every container, so that every container can access it.

In fact, all of the above features can be implemented as long as one set of containers share some Linux Namespaces and mount the same volume. Below, we will analyze how the CRI Manager in PouchContainer implements the Pod model by creating a Pod:

1. When Kubelet creating a Pod, the CRI `RunPodSandbox` would be called first. The implementation of the interface by CRI Manager is to create a special container, called "infra container". 
From the point of view of the container implementation, it is not special, it is nothing but call the Container Manager and create a normal container with an image named `pause-amd64:3.0`.  However, from the perspective of the whole Pod container group, it has a special role, which contributes its own Linux Namespace as Linux shared namespace of the container mentioned above, connecting all containers in the container group. It is more like a carrier that carries all the other containers in the Pod and provides the infrastructure for their operation. In general, we also use an infra container to represent a Pod.

2. After the infra container is created, Kubelet creates other containers in the pod container group. Each time a container is created, the two CRI `CreateContainer` and `StartContainer` are continuously called. For `CreateContainer`, CRI Manager simply converts the container configuration in CRI format to a PouchContainer format container configuration and passes it to the Container Manager, which completes the specific container creation. The only issue we need to care about here is how the container adds the Linux Namespace of the infra container mentioned above. In fact, the implementation is very simple. There are three parameters `PidMode`, `IpcMode` and `NetworkMode` in the container configuration parameters of Container Manager, which are used to configure the Pid Namespace, IPC Namespace and Network Namespace of the container respectively. In general terms, the configuration of the container's Namespace generally has two modes: "None" mode, which creates the container's unique Namespace, and the other is the "Container" mode, that is, adding the Namespace of another container. We only need to configure the above three parameters as "Container" mode and add the Namespace of the infra container. CRI Manager does not need to care how they are been added. For `StartContainer,` the CRI Manager simply does a layer of forwarding, gets the container ID from the request and calls the Container Manager's `Start` interface to start the container. 


3. Finally, Kubelet will continuously call the two CRI interfaces `ListPodSandbox` and `ListContainers` to get the running status of the container on this node. The `ListPodSandbox` lists the status of each infra container, and the `ListContainer` lists the status of other containers except the infra container. The problem is that there is no difference between the infra container and the other containers for the Container Manager. So how does CRI Manager distinguish between these containers? In fact, when creating containers, CRI Manager adds a label to the existing container configuration to indicate the type of the container. Therefore, when the `ListPodSandbox` and `ListContainers` interfaces are implemented, different types of containers can be filtered with the value of the label as a condition.


In conclusion, for the creation of Pod, the infra container is created first, then the other containers in Pod are, and the Linux Namespace of the infra container is added.